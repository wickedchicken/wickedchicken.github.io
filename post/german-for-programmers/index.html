<!DOCTYPE html>
<html lang="en-US">

<head>
<meta charset="utf-8" />
<meta name="author" content="Mike Stipicevic" />
<meta name="description" content="Mike Stip&#39;s personal blog" />
<meta name="keywords" content="blog, tech" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.53" />

<link rel="canonical" href="https://wickedchicken.github.io/post/german-for-programmers/">
<meta property="og:title" content="German for Programmers" />
<meta property="og:description" content="After 2 years of learning German I&rsquo;ve noticed that, for the most part, you can go a long way by mapping foreign concepts to ones that you already know. In particular, I&rsquo;ve had success mapping aspects of German grammar to programming concepts I use every day. After all, programmers deal with weird grammars all the time, why not take advantage of that skill?
Gendered nouns: forward error correction Probably the first difficulty people run into when learning German is memorizing the gender of each noun and properly declining that noun&rsquo;s articles when used in a sentence." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wickedchicken.github.io/post/german-for-programmers/" /><meta property="article:published_time" content="2019-02-03T21:37:26&#43;01:00"/>
<meta property="article:modified_time" content="2019-02-03T21:37:26&#43;01:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="German for Programmers"/>
<meta name="twitter:description" content="After 2 years of learning German I&rsquo;ve noticed that, for the most part, you can go a long way by mapping foreign concepts to ones that you already know. In particular, I&rsquo;ve had success mapping aspects of German grammar to programming concepts I use every day. After all, programmers deal with weird grammars all the time, why not take advantage of that skill?
Gendered nouns: forward error correction Probably the first difficulty people run into when learning German is memorizing the gender of each noun and properly declining that noun&rsquo;s articles when used in a sentence."/>



<meta itemprop="name" content="German for Programmers">
<meta itemprop="description" content="After 2 years of learning German I&rsquo;ve noticed that, for the most part, you can go a long way by mapping foreign concepts to ones that you already know. In particular, I&rsquo;ve had success mapping aspects of German grammar to programming concepts I use every day. After all, programmers deal with weird grammars all the time, why not take advantage of that skill?
Gendered nouns: forward error correction Probably the first difficulty people run into when learning German is memorizing the gender of each noun and properly declining that noun&rsquo;s articles when used in a sentence.">


<meta itemprop="datePublished" content="2019-02-03T21:37:26&#43;01:00" />
<meta itemprop="dateModified" content="2019-02-03T21:37:26&#43;01:00" />
<meta itemprop="wordCount" content="2585">



<meta itemprop="keywords" content="" />


<link rel="stylesheet" href="https://wickedchicken.github.io/css/layout.css" />
<style type="text/css">
body {
  background-color: #202024;
  color: #EFE0B9;
}

a { color: #EFE0B9; }

pre {
  background: #643B0F;
  border: 1px solid #EFE0B9;
  border-radius: 5px;
}

code {
  background: #643B0F;
}

blockquote {
  background: #643B0F;
  border-left: 3px solid #EFE0B9;
}

table {
  margin: 1em auto;
  border-collapse: collapse;
}

table, th, td {
  border: 1px solid #EFE0B9;
}

th {
  background: #EFE0B9;
  color: #202024;
}

.siteTitle a { color: #B7521E; }

.post .content h1{ color: #B7521E; }
.post .content h2{ color: #B7521E; }
.post .content h3{ color: #B7521E; }
.post .content h4{ color: #B7521E; }
.post .content h5{ color: #B7521E; }
.post .content h6{ color: #B7521E; }
.post .content a:hover { color: #B7521E; }
.social-link:hover { color: #B7521E; }
.nav-item-title:hover { color: #B7521E; }
.tag a:hover { color: #B7521E; }
.copyright { color: #E4B04A }
.poweredby { color: #E4B04A }
.poweredby a { color: #E4B04A; }
.post-preview .title a{ color: #B7521E; }
.content-item a:hover{
  text-decoration: underline;
  color: #B7521E;
}
.post-list .title { color: #B7521E; }
.rmore { color: #B7521E; }
.terms .term a:hover {
  text-decoration: underline;
  color: #B7521E;
}

</style>



<title>


     German for Programmers 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://wickedchicken.github.io">Outer Haven</a>
    </div> 

    
    
    <a class="nav-item" href="https://wickedchicken.github.io/post/"><div class="nav-item-title">Posts</div></a>
    
    <a class="nav-item" href="https://wickedchicken.github.io/tags/"><div class="nav-item-title">Tags</div></a>
    

  </nav>
</div>

  
<div class="social-links-header">

  

  <a href="http://stipicevic.com" target="_blank"><div class="social-link">main</div></a>

  
  <a href="https://github.com/wickedchicken" target="_blank"><div class="social-link">github</div></a>
  

  

  
  <a href="https://twitter.com/wickedchicken" target="_blank"><div class="social-link">twitter</div></a>
  

  

</div>


</header>


<article class="post">
    <h1 class="title"> German for Programmers </h1>
    <div class="content"> 

<p>After 2 years of learning German I&rsquo;ve noticed that, for the most part, you can
go a long way by mapping foreign concepts to ones that you already know. In
particular, I&rsquo;ve had success mapping aspects of German grammar to programming
concepts I use every day. After all, programmers deal with weird grammars all
the time, why not take advantage of that skill?</p>

<h3 id="gendered-nouns-forward-error-correction">Gendered nouns: forward error correction</h3>

<p>Probably the first difficulty people run into when learning German is memorizing
the gender of each noun and <a href="https://i.redd.it/hotye1wdbg511.jpg">properly declining</a> that noun&rsquo;s articles
when used in a sentence. While the grammar is mostly regular here, two things
make this challenging: the nonsensical assignment of genders to nouns<sup class="footnote-ref" id="fnref:genders"><a href="#fn:genders">1</a></sup>
and the sheer amount of memorization required to select the correct declension
once the gender of the noun is known.</p>

<p>While no amount of explanation can fully console someone going through this
process, I&rsquo;ve made peace with gendered nouns by treating them as a form of
<a href="https://en.wikipedia.org/wiki/Forward_error_correction">forward error correction</a>. Forward error correction is an encoding
technique that adds extra &ldquo;redundant&rdquo; information to a message such that if
parts of the message are lost or garbled, the extra information can be used to
reconstruct the original message <em>without</em> having to ask the sender to
retransmit.</p>

<p>If you&rsquo;ve ever had to attach words to letters to spell something complicated
over the phone (S, T as in Tom, I, P as in Peter, I, C as in Charlie, &hellip;) you
understand forward error correction. Underlying these methods
are an agreed-upon set of rules that both sender and receiver know (&ldquo;I&rsquo;m going
to say a word that we both know, and the letter I&rsquo;m trying to communicate to you
will be the first letter in that word&rdquo;). A more formal &ldquo;code&rdquo; would involve
agreeing to always use the <a href="https://en.wikipedia.org/wiki/NATO_phonetic_alphabet">NATO phonetic alphabet</a> when spelling
things out over the phone. When using this scheme, if you heard
&ldquo;{garbled}-ELTA,&rdquo; you can guess that
the sender said &ldquo;Delta&rdquo; because the rules were such that the sender couldn&rsquo;t
have said anything else (no other letter&rsquo;s pronunciation ends in &ldquo;elta&rdquo;).</p>

<p>Computers use a more complicated version of this to
protect bitstreams against different kinds of errors.
The &ldquo;rules that both sender and receiver know&rdquo; can be
<a href="https://en.wikipedia.org/wiki/Hamming(7,4)#Hamming_matrices">Hamming Matrices</a> <sup class="footnote-ref" id="fnref:hamming-explain"><a href="#fn:hamming-explain">2</a></sup>,
<a href="http://pfister.ee.duke.edu/courses/ecen604/rspoly.pdf">Reed-Solomon polynomials</a> <sup class="footnote-ref" id="fnref:reed-solomon-explain"><a href="#fn:reed-solomon-explain">3</a></sup>,
<a href="https://en.wikipedia.org/wiki/Convolutional_code">Markov Chains</a> <sup class="footnote-ref" id="fnref:convolutional-explain"><a href="#fn:convolutional-explain">4</a></sup>, or modifications and
combinations of all of these.</p>

<p>The genders of individual nouns and the grammatical rules to decline articles
and adjectives using those genders constitute <em>a shared set of rules that the
sender and receiver both know</em>. It may not approach the
<a href="https://en.wikipedia.org/wiki/Noisy-channel_coding_theorem">Shannon limit</a>, but German gendered nouns form a weird, organically
developed forward error correcting code. This might be a convoluted
example, but imagine trying to hear the difference between <em>Rat</em> and <em>Rad</em> over
a bad phone line. Your brain has to do this kind of reconstruction all the time,
you&rsquo;re just not usually conscious of it! &ldquo;Gib mir das Ra{d,t}&rdquo; makes the
distinction clear &ndash; a German speaker would decode it as <em>das Rad</em> immediately,
because that &ldquo;just sounds right.&rdquo; The declinations are just parity bits in the
sentence, and whatever &ldquo;just sounds right&rdquo; is actually an error-free solution
to a parity calculation.</p>

<h3 id="many-german-verb-constructs-are-just-context-managers">Many German verb constructs are just context managers</h3>

<p>The earliest &ldquo;weird&rdquo; form of German grammar you usually encounter is the
<em>trennbares Verb</em>. Much like &ldquo;turning on a switch&rdquo; is different than
&ldquo;turning a switch,&rdquo;
&ldquo;Ich schalte den Schalter ein&rdquo; is different than &ldquo;Ich schalte den Schalter.&rdquo; The
main difference is that in English the rest of the sentence continues after the
&ldquo;on,&rdquo; while in German the &ldquo;on&rdquo; always has to come at the end of the clause. So
while in English we would say &ldquo;I&rsquo;m calling up a friend with my new phone,&rdquo; in
German you would say &ldquo;Ich rufe einen Freund mit meinem neuen Telefon an.&rdquo;
Loosely translated, this would be &ldquo;I&rsquo;m calling a friend with my new phone up.&rdquo;</p>

<p>The fact that the <em>an</em> comes at the end of a conjugated clause using <em>anrufen</em>
works the same way Python&rsquo;s <a href="https://www.python.org/dev/peps/pep-0343/#specification-the-with-statement">context managers</a>
work<sup class="footnote-ref" id="fnref:other-lang-context"><a href="#fn:other-lang-context">5</a></sup>. Context managers take a bit of
explaining if you&rsquo;re not used to them, but they are a powerful way to harness
the <a href="https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions"><code>finally</code></a> clause in Python. <code>finally</code> lets you execute code when
a code execution leaves a certain scope. The most-often used context manager is
in the <code>file</code> object; it ensures that the file is closed when the object goes
out of scope so you can&rsquo;t forget to close it.</p>

<pre><code class="language-python">with open('workfile') as f:
    read_data = f.read()
</code></pre>

<p>replaces</p>

<pre><code class="language-python">f = open('workfile')
try:
    read_data = f.read()
finally:
    f.close()
</code></pre>

<p>In addition to cleverly eliminating errors regarding forgotten cleanup and
further consolidating code, context
managers help ensure the correct ordering of cleanup code. This is because
as context managers are combined, they maintain a LIFO ordering &ndash; the innermost
context manager&rsquo;s exit code is executed first, followed by the next innermost,
until the entire stack has been executed.</p>

<p>This LIFO ordering can be seen with more complicated &ldquo;context-manager-like&rdquo;
German verb constructs. Take a <em>Modalverb</em> such as <em>können</em> (&ldquo;is able to&rdquo;)
combined with the dependent clause created by <em>ob</em> (&ldquo;if&rdquo;). Both <em>ob</em> and
<em>können</em>
require that the verb comes at the end of the clause involving it &ndash; &ldquo;Ich weiß
nicht, ob der Zug kommt&rdquo; (&ldquo;I don&rsquo;t know if the train is coming&rdquo;). When using
both <em>ob</em> and <em>können</em> together, the LIFO ordering reveals itself: &ldquo;Ich weiß
nicht, ob sie tanzen kann.&rdquo;
Here, <em>können</em> ends its clause with <em>tanzen</em>, and <em>ob</em> ends its clause with
<em>können</em>. Since they&rsquo;re chained, this means that <em>können</em> itself goes at the
end, and its clause comes <em>before</em> it (this is determined by <em>ob</em>, take a look
at the <em>Zug</em> example again).
Visually, it becomes &ldquo;ob [(sie tanzen) kann],&rdquo; where () signifies the
scope for <em>können</em> and [] signifies the scope for <em>ob</em>. In both scopes, the
relevant verb comes at the end, and the ordering follows the inverse of how
the scopes are introduced.</p>

<p>Theoretically this can go even further, although it becomes quite complicated to
parse. Generously contributed by <a href="http://www.unhyperbolic.org/">Matthias Görner</a>, the sentence
&ldquo;Ich stimme dem
Maler, der die Meinung, dass Rot keine Farbe ist, vertritt, zu&rdquo;<sup class="footnote-ref" id="fnref:convoluted"><a href="#fn:convoluted">6</a></sup>
layers a
<em>trennbares Verb</em> (<em>zustimmen</em>), a relative clause (<em>der &hellip; vertritt</em>), and a
dependent clause (<em>dass &hellip; ist</em>) to demonstrate the LIFO ordering. The
translation is &ldquo;I agree with the painter, who represents the opinion that red is
not a color.&rdquo;</p>

<h3 id="prepositions-claim-different-areas-of-cognitive-space-in-english-and-german">Prepositions claim different areas of &lsquo;cognitive space&rsquo; in English and German</h3>

<p>In 2010, the xkcd author ran a color survey looking for similarities in how
people described colors. Out of that came a chart mapping a continuous color
space to discrete English words<sup class="footnote-ref" id="fnref:colors"><a href="#fn:colors">7</a></sup>:</p>

<figure><a href="https://blog.xkcd.com/2010/05/03/color-survey-results/">
    <img src="https://wickedchicken.github.io/static/xkcd_colors.png" width="70%"/> </a><figcaption>
            <h4>clusters of English names for colors</h4>
        </figcaption>
</figure>


<p>More detailed analyses have been done by <a href="https://jov.arvojournals.org/article.aspx?articleid=2121523">Lindsey and Brown</a>
and <a href="https://jov.arvojournals.org/article.aspx?articleid=2608579">Kuriki et al.</a> for American English and Japanese respectively
(thanks to <a href="https://twitter.com/sundress">Alice Boxhall</a> for helping me find these!). The most
striking part of this work is that Japanese speakers are far more likely to
consider &ldquo;light blue&rdquo; to be a basic color term than English speakers would:</p>

<figure>
    <img src="https://wickedchicken.github.io/static/raw_colors.png"/> <figcaption>
            <h4>colors participants were asked to name</h4>
        </figcaption>
</figure>


<figure>
    <img src="https://wickedchicken.github.io/static/english_colors.png"/> <figcaption>
            <h4>colors that American English speakers were most likely to assign</h4>
        </figcaption>
</figure>


<figure>
    <img src="https://wickedchicken.github.io/static/japanese_colors.png"/> <figcaption>
            <h4>colors that japanese speakers were most likely to assign</h4>
        </figcaption>
</figure>


<p>Just as our word &ldquo;blue&rdquo; covers both &ldquo;blue&rdquo; and &ldquo;light-blue&rdquo; in Japanese<sup class="footnote-ref" id="fnref:teal"><a href="#fn:teal">8</a></sup>,
so do English prepositions cover a different &ldquo;semantic space&rdquo; than German
prepositions. Take <em>bei</em>: according to <a href="https://de.pons.com/%C3%BCbersetzung?q=bei&amp;l=deen&amp;in=&amp;lf=en">Pons</a>, depending on the
situation <em>bei</em> can function like the English prepositions with, for, in, to,
near, by, among, and during. Talk about multi-purpose!
<a href="https://de.pons.com/%C3%BCbersetzung?q=auf&amp;l=deen&amp;in=&amp;lf=en"><em>auf</em></a> has the same problem, and it doesn&rsquo;t help that <em>auf</em> is one
of the prepositions that <a href="http://www.canoo.net/services/OnlineGrammar/Wort/Praeposition/Kasus/2Kasus.html?lang=en">change meaning</a> depending on which case
it&rsquo;s used with.</p>

<p>This became infuriating as I would memorize the translation given by the
dictionary, then stare in disbelief at <em>auf</em> being used for both &ldquo;The paper is
on the table&rdquo; and &ldquo;We speak in English&rdquo; (&ldquo;Das Papier liegt auf dem Tisch&rdquo; and
&ldquo;Wir sprechen auf Englisch&rdquo;).
The best advice I have is to ignore
the English translations and senses entirely. <em>um</em> simply isn&rsquo;t &ldquo;around,&rdquo; it
covers a different shape over the semantic space and should be treated on its
own. Don&rsquo;t pay attention to translations, don&rsquo;t try to &ldquo;guess&rdquo; how it might work
based on prepositions you know, just learn them afresh (usually by memorizing
which prepositions often go with which verbs, or memorizing common phrases like
&ldquo;<em>auf der Hand</em>&rdquo;).</p>

<h3 id="declined-the-s-are-just-how-german-does-kwargs">Declined &lsquo;the&rsquo;s are just how German does kwargs</h3>

<p>Most of the toil around early German involves learning how to properly decline
articles. While the <a href="#gendered-nouns-forward-error-correction">genderedness</a>
causes its own problems, even the declination rules themselves can take time to
learn. The advantage of having declined articles is that subject/object order
isn&rsquo;t fixed.</p>

<p>For example, take the English sentence &ldquo;The man gives the ball to the dog.&rdquo;
There&rsquo;s no way to rearrange the sentence to have the same meaning without adding
extra punctuation or words &ndash; &ldquo;the ball gives the dog to the man&rdquo; has a
completely different meaning. The best you can do is maybe &ldquo;to the dog, the man
gives the ball&rdquo; but that extra comma changes the structure a bit. In German,
all three nouns are masculine and would nominally be <em>der Mann</em>, <em>der Ball</em>, and
<em>der Hund</em>. However, each <em>der</em> changes whether the word is a subject
(<em>Nominativ</em>), direct object (<em>Akkusativ</em>), or indirect object (<em>Dativ</em>).
This means that the above sentence in German could be &ldquo;Der Mann gibt dem Hund
den Ball.&rdquo;
Because each &ldquo;the&rdquo; is declined (<em>der</em>, <em>den</em>, and <em>dem</em>), German
allows you to be more flexible with where you put your subjects and objects
around the verb.</p>

<p>There are <a href="http://www.dartmouth.edu/~deutsch/Grammatik/WordOrder/WordOrder.html">additional rules around object placement</a> which restrict
some permutations, so ultimately it&rsquo;s possible to write the same sentence three
ways:</p>

<ol>
<li>&ldquo;Der Mann gibt dem Hund den Ball.&rdquo;</li>
<li>&ldquo;Den Ball gibt der Mann dem Hund.&rdquo;</li>
<li>&ldquo;Dem Hund gibt der Mann den Ball.&rdquo;</li>
</ol>

<p>Each way can be used to emphasize a different object, but they all mean the same
grammatically.</p>

<p>In Python, a function can be called with positional and keyword arguments.
Usually positional arguments are specified in the signature, but unlimited
&lsquo;extra&rsquo; positional arguments and keyword arguments can be collected by convention
in an &ldquo;<code>*args</code>&rdquo; array and a &ldquo;<code>**kwargs</code>&rdquo; dictionary respectively<sup class="footnote-ref" id="fnref:kwargs"><a href="#fn:kwargs">9</a></sup>.
<code>kwargs</code> have the nice property that they can be given in any
order<sup class="footnote-ref" id="fnref:kwarg-ordering"><a href="#fn:kwarg-ordering">10</a></sup>, but the price is that you have to refer to them by
keyword:</p>

<pre><code class="language-python">def giver_pos(subject, direct_object, indirect_object):
    &quot;&quot;&quot;This uses English-style positional ordering.&quot;&quot;&quot;
    print(f'The {subject} gives the {direct_object} to the {indirect_object}.')


def giver_kwargs(**kwargs):
    &quot;&quot;&quot;This uses Germanish free-form keyword ordering.&quot;&quot;&quot;
    subject = kwargs['subject']
    direct_object = kwargs['direct_object']
    indirect_object = kwargs['indirect_object']
    print(f'The {subject} gives the {direct_object} to the {indirect_object}.')


# These print the same thing
giver_pos('man', 'ball', 'dog')
giver_kwargs(subject='man', direct_object='ball', indirect_object='dog')
giver_kwargs(direct_object='ball', indirect_object='dog', subject='man')
giver_kwargs(indirect_object='dog', subject='man', direct_object='ball')
giver_kwargs(subject='man', indirect_object='dog', direct_object='ball')

# This does *not* print the same thing
giver_pos('ball', 'man', 'dog')
</code></pre>

<p>Note how the positional one loses functionality but requires less typing. You
need <em>some</em> kind of information to differentiate in which sense a word is to
be used, and each way has a tradeoff. English chooses to use position for
simplicity and loses flexibility, German chooses to use declination for
flexibility but loses simplicity.</p>

<h3 id="position-2-is-just-a-delay-slot">Position 2 is just a delay slot</h3>

<p>In normal sentences, German verbs stay in &ldquo;Position 2,&rdquo; meaning right after the
first clause. Directly translated, this can sound quite weird! &ldquo;The dog goes to
the vet tomorrow&rdquo; could become &ldquo;tomorrow goes the dog to the vet.&rdquo; There are
still <a href="https://en.wikipedia.org/wiki/V2_word_order#Vestiges_of_V2_in_Modern_English">kernels of this in modern English</a> but in general it can take a long
time to get used to the fixed aspect of German word order.</p>

<p>Thinking of <a href="https://en.wikipedia.org/wiki/Delay_slot">delay slots</a> in older computer architectures helped me
conceptualize Position 2 a little better. Processors need to determine where
to read instructions after a branch (say, which side of an if statement to
execute). In the case of pipelined processors, this calculation can be blocked
while waiting for a previous value to become computed<sup class="footnote-ref" id="fnref:branches"><a href="#fn:branches">11</a></sup>. Delay slots
were used by pipelined CPUs to solve this problem before modern
<a href="https://en.wikipedia.org/wiki/Out-of-order_execution">out-of-order execution</a> methods rendered them unnecessary. The older
processors were unable to look ahead to compute possible branch targets, so
they forced the developer to give a one or two cycle &ldquo;heads up&rdquo; that
a branch was coming. The processor used this time to compute the jump targets
with the
caveat that the programmer couldn&rsquo;t insert <a href="https://en.wikipedia.org/wiki/Hazard_(computer_architecture)">hazards</a> in the delay slots
&ndash; that would defeat the entire purpose of the delay.</p>

<p>I see verbs staying in Position 2 the same way: they guarantee your brain gets a
heads up on what action is about to happen, even if you have a long flourishing
adverbial or subject clause. &ldquo;On Fridays I eat pizza&rdquo; becomes &ldquo;On Fridays eat
[hey the subject&rsquo;s coming later but just fyi the subject is eating] I pizza.&rdquo;
It&rsquo;s possible to get lost in
<a href="#many-german-verb-constructs-are-just-context-managers">complicated German sentences</a>,
so forcing the important bits up front just seems helpful.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:genders"><p><em>Der Junge</em>, boy, is masculine. <em>Das Mädchen</em>, girl, is neutral.
<em>Die Männlichkeit</em>, masculinity, is female. Yes, these follow &ldquo;common
rules&rdquo; but that still doesn&rsquo;t mean they make sense.</p>
 <a class="footnote-return" href="#fnref:genders"><sup>[return]</sup></a></li>

<li id="fn:hamming-explain"><p>Mix the bits into overlapping checksums so if one checksum
fails, you can reconstruct the original bit from the other checksums.</p>
 <a class="footnote-return" href="#fnref:hamming-explain"><sup>[return]</sup></a></li>

<li id="fn:reed-solomon-explain"><p>Encode the data as a polynomial, then send points that
sit on that polynomial such that you can reconstruct the polynomial from the
points received. By sending way more points than necessary you can correctly
reconstruct the original polynomial even if some points are missing or
altered.</p>
 <a class="footnote-return" href="#fnref:reed-solomon-explain"><sup>[return]</sup></a></li>

<li id="fn:convolutional-explain"><p>Convolutional codes repeatedly mix new data with
previously emitted data. There are a few ways to decode this, but the
<a href="https://en.wikipedia.org/wiki/Viterbi_algorithm">Viterbi algorithm</a> is pretty cool &ndash; you use dynamic programming
to reconstruct the input (represented as a path through a Markov chain)
that was most likely to have generated the observed output (the convolved
and emitted data). This works even if that output was emitted unreliably.</p>
 <a class="footnote-return" href="#fnref:convolutional-explain"><sup>[return]</sup></a></li>

<li id="fn:other-lang-context"><p>Other languages have constructs like this. Go has
<a href="https://tour.golang.org/flowcontrol/12">defer</a>, Rust has <a href="https://github.com/bluss/scopeguard">scopeguard</a>, C++ has
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>, and Scheme has <a href="https://www.scheme.com/tspl3/io.html">call-with-input-file</a>.</p>
 <a class="footnote-return" href="#fnref:other-lang-context"><sup>[return]</sup></a></li>

<li id="fn:convoluted"><p>Yes, I know this is not really how someone would write that
sentence. Please excuse the artistic license taken here.</p>
 <a class="footnote-return" href="#fnref:convoluted"><sup>[return]</sup></a></li>

<li id="fn:colors"><p>Remember, what we call &ldquo;red&rdquo; <a href="http://hyperphysics.phy-astr.gsu.edu/hbase/vision/specol.html">maps</a> to a range spanning
625-740nm, and that precise range might change person to person.</p>
 <a class="footnote-return" href="#fnref:colors"><sup>[return]</sup></a></li>

<li id="fn:teal"><p>It should be noted that in the study of American English, about <sup>1</sup>&frasl;<sub>3</sub> of
respondents used &ldquo;teal&rdquo; instead of &ldquo;blue&rdquo; when describing the lighter,
greener shades of &ldquo;blue.&rdquo;</p>
 <a class="footnote-return" href="#fnref:teal"><sup>[return]</sup></a></li>

<li id="fn:kwargs"><p><code>kwargs</code> is pronounced like the fictional word &ldquo;quargs,&rdquo; and any
other pronunciation is incorrect.</p>
 <a class="footnote-return" href="#fnref:kwargs"><sup>[return]</sup></a></li>

<li id="fn:kwarg-ordering"><p><a href="https://www.python.org/dev/peps/pep-0468/">PEP 468</a>,
introduced in Python 3.6, preserves the keyword argument order in the
dictionary given to the called function. This enables cases where that might
be useful.</p>
 <a class="footnote-return" href="#fnref:kwarg-ordering"><sup>[return]</sup></a></li>

<li id="fn:branches"><p>If a processor needs to know which side of <code>if (x + 4) &gt; 5</code> to
execute, it can&rsquo;t do anything until it knows what <code>x + 4</code> is. This can be a
problem in pipelined processors where most of the speed gains come from
starting an instruction before the instruction before it has finished.
Immense performance gains can be had if you use tricks to &ldquo;fill up&rdquo; the
downtime while you&rsquo;re waiting for a critical instruction to finish. For
example, if you have
<code>
y = 5 + 6
if (x + 4) &gt; 5:
    print('hello!')
else:
    print('goodbye!')
</code> you can start computing <code>(x + 4)</code> <em>before</em> <code>y = 5 + 6</code>, so that the
answer is ready when the if statement needs to determine which <code>print</code>
statement to execute. You&rsquo;re just rearranging when things execute to make
sure there is as little downtime as possible.</p>
 <a class="footnote-return" href="#fnref:branches"><sup>[return]</sup></a></li>
</ol>
</div>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
</div>

    <div class="date"> Feb 3, 2019 </div>
  </div>

</footer>


  


</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/wickedchicken" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://twitter.com/wickedchicken" target="_blank"><div class="social-link">Twitter</div></a>
  

  

  <div class="social-link">
  <a href="https://wickedchicken.github.io/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright"> Copyright (c) 2018, all rights reserved. Theme based on <a href="https://github.com/gyorb/hugo-dusk">hugo-dusk</a>. </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

